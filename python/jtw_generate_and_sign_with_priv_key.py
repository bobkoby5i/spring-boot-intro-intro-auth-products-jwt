####################################################################################
#
#  in this script
#  1. use python library to generate and sign jwt.
#  2. JWT token is correct and signed but it is not 100% = jwt token generated by SpringBoot
#  3. I use crypto libraries to generate step bay step 
#     - base64_url_safe
#     - SHA256 to generate hash 
#     - RSA, PKCS1_v1_5 to generate signature. 
#     100% match with SpringBoot JWT token
#
####################################################################################


import hashlib
import jwt
import json
import base64


from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_v1_5
from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
from Crypto.Hash import SHA512, SHA384, SHA256, SHA, MD5
from Crypto import Random
from base64 import b64encode, b64decode
import rsa

import binascii




####################################################################################
#
#  1. Generate JWT based on payload and hader
#  Results:
#  Our token does not match java
#  - in header python swiched 'alg':'RS256','typ':'JWT' -> 'alg':'typ':'JWT','RS256'
#  - signature is different 
####################################################################################

# My pub/priv keys from my jsva
private_key   = open('inp/key.prv').read()  
public_key    = open('inp/key.pub').read()  

private_key
public_key

# read json from disk
with open('inp/data_payload.txt') as json_file:
    json_payload = json.load(json_file)
\

with open('inp/data_header.txt') as json_file:
    json_header = json.load(json_file)
\

json_header
json_payload

jwt_token = jwt.encode(json_payload, private_key, algorithm='RS256', headers={'alg':'RS256','typ':'JWT'}).decode('utf-8')
jwt_token
jwt.decode(jwt_token,public_key,algorithm='RS256',options={'verify_exp': False})

f=open("out/python_jwt_token.txt", "w")
f.write(jwt_token)
f.close()

	
#
#  compare
#

java_jwt_token       = open('inp/java_jwt.txt').read()
java_b64_header      = open('inp/java_b64_header.txt').read()
java_b64_payload     = open('inp/java_b64_payload.txt').read()
java_b64_signature   = open('inp/java_b64_signature.txt').read()

tab=jwt_token.split('.')
jwt_header  = tab[0]
jwt_payload = tab[1]
jwt_sign    = tab[2]

# here token is differen
jwt_token == java_jwt_token 

java_b64_header
jwt_header
jwt_header == java_b64_header

jwt_payload
java_b64_payload
jwt_payload == java_b64_payload

jwt_sign
java_b64_signature
jwt_sign == java_b64_signature



########################################################
#
#  Generate header.base64 i payload.base64
#
#######################################################

data =  json_header
print(type(data))  #dict
datastr = json.dumps(data)
datastr=datastr.replace(" ", "") # need to cleanum because b64 does not match what java does. 
print(type(datastr)) #str
print(datastr)
encoded = base64.urlsafe_b64encode(datastr.encode('utf-8'))  #1 way
#print(base64.encodebytes(datastr.encode())) #2 method
print(encoded)
print(type(encoded)) #bin
s=encoded.decode("utf-8")
print(s)
"""
Removes any `=` used as padding from the encoded string.
"""
s=s.rstrip("=")
print(type(s)) #str
print(s)
b64_header=s
b64_header

print('Our encoded header: ' + b64_header)
print('Java Spring header: ' + java_b64_header)
print('Python jwt  header: ' + jwt_header)
java_b64_header==b64_header


data = json_payload
print(type(data))  #dict
datastr = json.dumps(data)
datastr=datastr.replace(" ", "") # need to cleanum because b64 does not match what java does. 
print(type(datastr)) #str
print(datastr)
encoded = base64.urlsafe_b64encode(datastr.encode('utf-8'))  #1 way
#print(base64.encodebytes(datastr.encode())) #2 method
print(encoded)
print(type(encoded)) #bin
s=encoded.decode("utf-8")
print(s)
"""
Removes any `=` used as padding from the encoded string.
"""
s=s.rstrip("=")
print(type(s)) #str
print(s)
b64_payload=s
b64_payload


print('Our encoded payload: ' + b64_payload)
print('Java Spring payload: ' + java_b64_payload)
print('Python jwt  payload: ' + jwt_payload)
java_b64_payload==b64_payload


########################################################
#
#  Create signature. 
#
#######################################################

private_key_str   = open('inp/key.prv').read()  
public_key_str    = open('inp/key.pub').read()  
private_key_str
public_key_str

private_key  = RSA.import_key(open("inp/key.prv").read())
public_key   = RSA.import_key(open("inp/key.pub").read())
private_key
public_key

#################################################### 
# concatenate header.payloas
# convert b64_data string to bin
# SHA256
# using RSA kesy

print('Hashing..... sha256')
b64_data = b64_header + "." + b64_payload
b64_data
data = b64_data.encode('utf-8') #bin
data
data_hash_hex=hashlib.sha256(data).hexdigest()
data_hash_hex
'4aa1ca9a3a7d024c65da76b2f02ac5e57aaa1c5561930c6efc78cd63fba7047f - online generated for header.payload'


hasher = SHA256.new(data)
hasher
hasher.hexdigest()

private_key  = RSA.import_key(open("inp/key.prv").read())
public_key   = RSA.import_key(open("inp/key.pub").read())

signer = PKCS115_SigScheme(private_key)
signature = signer.sign(hasher)
signature
print("Signature:", binascii.hexlify(signature))

signer    = PKCS1_v1_5.new(private_key)
signature = signer.sign(hasher)
signature
print("Signature:", binascii.hexlify(signature))

b64_signature     = base64.urlsafe_b64encode(signature)  #1 way
b64_signature_str =  b64_signature.decode('utf-8')
b64_signature_str
java_b64_signature

# if urlsafe not user
#b64_signature_str = b64_signature_str.replace('/','_')
#b64_signature_str = b64_signature_str.replace('+','-')
b64_signature_str = b64_signature_str.rstrip('=')

b64_signature_str == java_b64_signature

my_jwt_token   = b64_header + "." + b64_payload + "." + b64_signature_str
my_jwt_token
java_jwt_token       = open('inp/java_jwt.txt').read()

print(my_jwt_token == java_jwt_token)

f=open("out/my_RSA_jwt_token.txt", "w")
f.write(my_jwt_token)
f.close()


###############################
#  HERE WE VERIFY JAVA JWT SIGNATURE
#  header payload signature
# 

public_key   = RSA.import_key(open("inp/key.pub").read())
java_jwt_token       = open('inp/java_jwt.txt').read()
(h,p,s) = java_jwt_token.split('.')
missing_padding = len(s) % 4
if missing_padding:
	s += '='* (4 - missing_padding)

	
s
signature = base64.urlsafe_b64decode(s)
print("Signature:", binascii.hexlify(signature))

# Verify valid PKCS#1 v1.5 signature (RSAVP1)
data = (h + "." + p)
data = data.encode('utf-8')
data 
hash = SHA256.new(data)
hash.hexdigest()
#signer = PKCS115_SigScheme(public_key)
signer = PKCS115_SigScheme(public_key)
try:
    signer.verify(hash, signature)
    print("Signature is valid. OK")
except:
    print("Signature is invalid. ERROR")

signer = PKCS1_v1_5.new(public_key)
try:
    signer.verify(hash, signature)
    print("Signature is valid. OK")
except:
    print("Signature is invalid. ERROR")



#
# example  werify   with SigScheme
#

from Crypto.Signature.pkcs1_15 import PKCS115_SigScheme
# Verify valid PKCS#1 v1.5 signature (RSAVP1)
msg = b'A message for signing'
hash = SHA256.new(msg)
signer = PKCS115_SigScheme(keyPair)
try:
    signer.verify(hash, signature)
    print("Signature is valid.")
except:
    print("Signature is invalid.")

# Verify invalid PKCS#1 v1.5 signature (RSAVP1)
msg = b'A tampered message'
hash = SHA256.new(msg)
signer = PKCS115_SigScheme(keyPair)
try:
    signer.verify(hash, signature)
    print("Signature is valid.")
except:
    print("Signature is invalid.")


#################################################### 
#  RSA GEN
#  RSA: Sign / Verify - Example
#  for Token use The RSA Signature Standard PKCS#1
#  https://cryptobook.nakov.com/digital-signatures/rsa-sign-verify-examples
#
#

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
import binascii

from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA512, SHA384, SHA256, SHA, MD5
from Crypto import Random
from base64 import b64encode, b64decode


random_generator = Random.new().read
keysize = 1024
keyPair = RSA.generate(1024)
keyPair = RSA.generate(keysize, random_generator)
prvKey, pubKey = keyPair, keyPair.publickey()

prvKey
pubKey


pubKey = keyPair.publickey()
print(f"Public key:  (n={hex(pubKey.n)}, e={hex(pubKey.e)})")
pubKeyPEM = pubKey.exportKey()
print(pubKeyPEM.decode('ascii'))

print(f"Private key: (n={hex(pubKey.n)}, d={hex(keyPair.d)})")
privKeyPEM = keyPair.exportKey()
print(privKeyPEM.decode('ascii'))

msg = b'A message for encryption'
encryptor = PKCS1_OAEP.new(pubKey)
encrypted = encryptor.encrypt(msg)
print("Encrypted:", binascii.hexlify(encrypted))

decryptor = PKCS1_OAEP.new(keyPair)
decrypted = decryptor.decrypt(encrypted)
print('Decrypted:', decrypted)

#
# signature veryfication example
# RSA sign the message
msg = b'A message for signing'
from hashlib import sha256
hash = int.from_bytes(sha256(msg).digest(), byteorder='big')
signature = pow(hash, keyPair.d, keyPair.n)
print("Signature:", hex(signature))

# RSA verify signature
msg = b'A message for signing'
hash = int.from_bytes(sha256(msg).digest(), byteorder='big')
hashFromSignature = pow(signature, keyPair.e, keyPair.n)
print("Signature valid:", hash == hashFromSignature)


#
#
#TEST EXCERCISE:
#	 input: Sample output (message + hex-encoded signature + PEM-encoded RSA public key):
#  SHA3_512
#  https://cryptobook.nakov.com/digital-signatures/exercises-rsa-sign-and-verify
#
data           = open("inp/test_p.txt").read()    #payload
public_key_str = open("inp/test_k.txt").read() #pub_key
public_key     = RSA.import_key(open("inp/test_k.txt").read()) #pub_key
signature      = open("inp/test_s.txt").read()    #signature

data
public_key_str
public_key
signature


#convert data to binary 
data = data.encode('utf-8')
data 

#add padding and decode signature
missing_padding = len(signature) % 4
if missing_padding:
	signature += '='* (4 - missing_padding)


signature = base64.urlsafe_b64decode(signature)
print("Signature:", binascii.hexlify(signature))	

#calcualte hash from payload
from Crypto.Hash import SHA3_512
hasher = SHA3_512.new(data)
hasher.hexdigest()

# why this method gives me  an error ? 
signer1 = PKCS115_SigScheme(public_key)
try:
    signer1.verify(hasher, signature)
    print("Signature is valid. OK")
except:
    print("Signature is invalid. ERROR")


# this method works 
signer2 = PKCS1_v1_5.new(public_key)
try:
    signer2.verify(hasher, signature)
    print("Signature is valid. OK")
except:
    print("Signature is invalid. ERROR")








#################################################### 
# concatenate header.payloas
# convert b64_data string to bin
# SHA256
# Problem with these keys
# https://stackoverflow.com/questions/57844204/how-to-encrypt-message-longer-than-53-bytes-using-rsa-encryption
# 1. must be long (when generated) i used 4096 for JWT TOKEN
# 2. this lib rsa is not working with my keys generated for java or kes generated from another pythin lib 
#    ONLY if keys generated and saved as save_ pkcs1  
#    BUT than ofcourse I can not gat same results. 
#    ALSO this jwt token does not work for me on http://jwt.io
# 
#    DOES NOT WORK FOR ME
#

print("Reading keys from files...")
my_public_key  = rsa.PublicKey.load_pkcs1(open("out/rsa-public.pem").read())    
my_private_key = rsa.PrivateKey.load_pkcs1(open("out/rsa-private.pem").read())    

#my_private_key = RSA.import_key(open("out/private.pem").read())
#my_public_key  = my_private_key.publickey()
print("Private:")
print(repr(my_private_key))
print("Public:")
print(repr(my_public_key))


b64_data = b64_header + "." + b64_payload
b64_data
data = b64_data.encode('utf-8') #bin
data
encrypted = b64encode(rsa.encrypt(data,  my_public_key))
decrypted = rsa.decrypt(b64decode(encrypted), my_private_key)
print(decrypted)
decrypted==data

signature = b64encode(rsa.sign(data, my_private_key, "SHA-256"))
print(signature)
verify = rsa.verify(data, b64decode(signature), my_public_key)
print(verify)

my_jwt_token   = b64_header + "." + b64_payload + "." + signature

f=open("out/my_rsa_lib_jwt_token.txt", "w")
f.write(my_jwt_token)
f.close()







###################  teraz nasz token

private_key  = RSA.import_key(open("inp/key.prv").read())
public_key   = RSA.import_key(open("inp/key.pub").read())
private_key
public_key


b64_data = b64_header + "." + b64_payload
b64_data
data = b64_data.encode('utf-8') #bin
data


from hashlib import sha256
hash = int.from_bytes(sha256(data).digest(), byteorder='big')
signature = pow(hash, keyPair.d, keyPair.n)
print("Signature:", hex(signature))
print(type(hash))  #int
print(type(signature))  #int




number = 128
bytestring = number.to_bytes(2, 'little')
print("integer {int} in bytes is {bytes}".format(int=number, bytes=bytestring))

x=signature
signature_bytes = x.to_bytes((x.bit_length() + 7) // 8, 'big')


b64_signature = b64encode(signature_bytes)
b64_signature
java_b64_signature   = open('inp/java_b64_signature.txt').read()
java_b64_signature
